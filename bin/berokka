#!/usr/bin/env perl
use strict;
use Bio::SeqIO;
use Bio::SearchIO;
use Data::Dumper;
use File::Path qw(make_path remove_tree);
use File::Spec;
use File::Copy;
use List::Util qw(min max);
use Cwd;
use File::Basename;
use Time::Piece;
use Time::Seconds;

# Globals
my $EXE = basename($0);
my $VERSION = "0.1";
my $URL = "https://github.com/tseemann/berokka";
my $AUTHOR = 'Torsten Seemann <torsten.seemann@gmail.com>';
my $OPSYS = $^O;


# Say hello
my $starttime = localtime;
if(0) {
msg("Hello", $ENV{USER} || 'stranger');
msg("This is $EXE $VERSION");
msg("Written by $AUTHOR");
msg("Homepage is $URL");
msg("Operating system is $OPSYS");
msg("Local time is $starttime");
}
msg("You ran: $0 @ARGV");

# Options
my(@Options, $debug, $version, $force, $outdir, $readlen, $keepfiles);
setOptions();

# Check options
@ARGV or err("Please provide FASTA contig file(s)");
my @FASTA = map { File::Spec->rel2abs($_) } @ARGV;
$outdir or err("Please specify the output folder with --outdir");

# Check we have the required binaries
for my $exe (qw(blastn)) {
  my $fullexe = find_exe($exe);
  if ($fullexe) {
    msg("Using $exe - $fullexe");
  }
  else {
    err("Could not find '$exe' - please install it.");
  }
}

# Make output folder
make_folder($outdir);
$outdir = File::Spec->rel2abs($outdir);

#msg("Changing into folder: $outdir");
my $cwd = getcwd();
chdir($outdir);

my $fout1 = Bio::SeqIO->new(-file=>">01.input.fa", -format=>'fasta');
my $fout2 = Bio::SeqIO->new(-file=>">02.trimmed.fa", -format=>'fasta');
open my $log, '>', "03.results.tab";
print $log "#sequence\told_len\tnew_len\ttrimmed\n";
my $nseq=0;
for my $fname (@FASTA) {
  my $fasta = Bio::SeqIO->new(-file=>$fname, -format=>'fasta');
  while (my $seq = $fasta->next_seq) {
    $nseq++;
    msg("*** [$nseq]", $seq->id, "***");
    $fout1->write_seq($seq);
    my $new = check_overhang($nseq, $seq);
    $fout2->write_seq( $new ? $new : $seq );
  }
}

#msg("Loaded $id sequences.");

unless ($keepfiles) {
  for my $i (1 .. $nseq) {
    my(@patt) = ("$i.fa", "$i.head.fa", "$i.bls");
    msg("Removing temporary files: @patt");
    unlink @patt;
  }
}

close $log;
open LOG, "03.results.tab";
print while (<LOG>);
msg("Returning to original folder: $cwd");
chdir($cwd);
msg("Results in: $outdir");


# Say our goodbyes
my $endtime = localtime;
my $walltime = $endtime - $starttime;
my $pretty = sprintf "%.2f minutes", $walltime->minutes;
msg("Walltime used: $pretty");
#msg("If you use this result please cite the Berokka paper:");
#msg("Seemann T (2017) Berokka: simple contig circulorientation BioRxiv doi:XXXX-YYYY");
#msg("Type '$EXE --citation' for more details.");

my @motd = (
  "May all your replicons circularise.",
  "Publishing a genome with overhang is so embarassing. Lucky you used $EXE !",
  "Found a bug? Post it at $URL/issues",
  "Have a suggestion? Tell me at $URL/issues",
  "The $EXE manual is at $URL/blob/master/README.md",
  "Did you know? $EXE is a play on the concept of overhang vs hangover",
);
srand( $$ + $walltime ); # seed
msg( $motd[ int(rand(scalar(@motd))) ] );
msg("Done.");

exit(0);


#----------------------------------------------------------------------
sub check_overhang {
  my($id, $seq) = @_;
  my $len = int( min( $seq->length, $readlen) );
  msg("Using first $len bp to BLAST");
  seq_to_fasta( "$id.fa", $seq );
  seq_to_fasta( "$id.head.fa", $seq->trunc(1, $len) );
  my $blastn_opt = "-evalue 1E-6 -dust no";
  run_cmd("blastn -query $id.head.fa -subject $id.fa -out $id.bls $blastn_opt");
  my $bls = Bio::SearchIO->new(-file=>"$id.bls", -format=>'blast');
  my $res = $bls->next_result or goto NOTRIM;
  my $hit = $res->next_hit;
  my $self_hsp = $hit->next_hsp; # 1st HSP is always to itself

  while (my $hsp = $hit->next_hsp) {
    msg(
      "blastn:", $hsp->start('query')."..".$hsp->end('query')."/".$res->query_length,
      "(".($hsp->strand('query') > 0 ? '+' : '-').")",
      "aligns to",
      $hsp->start('subject')."..".$hsp->end('subject')."/".$hit->length,
      "(".($hsp->strand('subject') > 0 ? '+' : '-').")",
      "at",
      sprintf("%.1f %%id", 100*$hsp->frac_identical('total') ),
    );
    if ($hsp->start('query') < 5
        and $hsp->end('subject') == $hit->length
        and $hsp->strand('query') > 0
        and $hsp->strand('subject') > 0) {
      my $end =  $hsp->start('subject') - $hsp->start('query');
      my $rem = $hit->length - $end + 1;
      msg($res->query_name,"keep 1..$end/".$hit->length, "(remove $rem bp)");
      print $log join("\t", $res->query_name, $hit->length, $end, $rem),"\n";
      return $seq->trunc(1, $end);
    }
  }

  msg($res->query_name, "- COULD NOT TRIM");
  print $log join("\t", $res->query_name, $hit->length, $hit->length, 0),"\n";
  return;
}


#----------------------------------------------------------------------
sub seq_to_fasta {
  my($fname, $seq) = @_;
  msg("Writing", $seq->id, "(", $seq->length, "bp ) to $fname");
  my $out = Bio::SeqIO->new(-file=>">$fname", -format=>'fasta', -flush=>1);
  $out->write_seq($seq);
}

#----------------------------------------------------------------------
sub make_folder {
  my($outdir) = @_;
  if (-d $outdir) {
    if ($force) {
      msg("Forced removal of existing --outdir $outdir (please wait)");
      remove_tree($outdir);
    }
    else {
      err("Folder '$outdir' already exists. Try using --force");
    }
  }
  make_path($outdir);
}

#----------------------------------------------------------------------
sub run_cmd {
  my($cmd, $quiet) = @_;
  msg("Running: $cmd") unless $quiet;
  system($cmd)==0 or err("Error $? running command");
}

#----------------------------------------------------------------------
sub find_exe {
  my($bin) = shift;
  for my $dir (File::Spec->path) {
    my $exe = File::Spec->catfile($dir, $bin);
    return $exe if -x $exe;
  }
  return;
}

#----------------------------------------------------------------------
sub msg {
  print STDERR "@_\n";
}

#----------------------------------------------------------------------
sub err {
  msg(@_);
  exit(1);
}

#----------------------------------------------------------------------
sub num_cpus {
  my($num)= qx(getconf _NPROCESSORS_ONLN); # POSIX
  chomp $num;
  return $num || 1;
}

#----------------------------------------------------------------------
sub version {
  print "$EXE $VERSION\n";
  exit(0);
}

#----------------------------------------------------------------------
sub read_fasta {
  my($fname) = @_;
  my $seq;
  my $id;
  open my $FASTA, '<', $fname or err("Could not open $fname");
  while (my $line = <$FASTA>) {
    chomp $line;
    if ($line =~ m/^>(\S+)/) {
      $id = $1;
      $seq->{$id} = '';
    }
    else {
      $seq->{$id} .= $line;
    }
  }
  close $FASTA;
  return $seq;
}

#----------------------------------------------------------------------
sub write_fasta {
  my($fname, $seq) = @_;
  open my $FASTA, '>', $fname or err("Could not write to $fname");
  for my $id (sort { $a cmp $b } keys %{$seq}) {
    print $FASTA ">$id\n", $seq->{$id}, "\n";
  }
  close $FASTA;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"debug!",  VAR=>\$debug, DEFAULT=>0, DESC=>"Debug info"},
    {OPT=>"version!",  VAR=>\&version, DESC=>"Print version and exit"},
    {OPT=>"outdir=s",  VAR=>\$outdir, DEFAULT=>'', DESC=>"Output folder"},
    {OPT=>"readlen=i",  VAR=>\$readlen, DEFAULT=>30_000, DESC=>"Approximat read length"},
    {OPT=>"force!",  VAR=>\$force, DEFAULT=>0, DESC=>"Force overwite of existing"},
    {OPT=>"keepfiles!",  VAR=>\$keepfiles, DEFAULT=>0, DESC=>"Keep intermediate files"},
  );

  (!@ARGV) && (usage());

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage:\n  $EXE [options] canu.contigs.fasta [another.fasta ...]\n";
  print "Options:\n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}

#----------------------------------------------------------------------
